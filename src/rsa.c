#include "rsa.h"


/*
A few details:
- The public exponent is by default set to 65537, you can indicate your at condition to respect the following range: [2**nBits-1, 2**nBits]
- I didn't implement (yet) the file format for the keypair. Mean that you can access access the key only from the struct

Warning: the keypair generated by this program aren't cryptographically secure !
My implementation is and only for a training purpose.
In consequence, do not use those keypairs for real life purpose !
*/


#define MIN_E_VALUE pow(2, 16)
#define MAX_E_VALUE pow(2, 256)


struct RSA_KEYPAIR {
    int modulus_size;
    BIGNUM *public_modulus;         
    BIGNUM *public_exponent;      
    BIGNUM *private_exponent; 
    BIGNUM *p_factor;
    BIGNUM *q_factor;
    BIGNUM *crt_exp_one;     
    BIGNUM *crt_exp_sec;
};

/* ASN.1 type RSAPrivateKey
RSAPrivateKey ::= SEQUENCE {
    modulus_size    Integer, --nBits
    modulus         BIGNUM, -- n
    publicExponent  BIGNUM, -- e
    privateExponent BIGNUM, -- d
    prime1          BIGNUM, -- p
    prime2          BIGNUM, -- q
    crt exponent1   BIGNUM, -- d mod (p-1)
    crt exponent2   BIGNUM, -- d mod (q-1)
}
*/



int consistency_test(struct RSA_KEYPAIR *kp_struct) {
    //This test verify that the generated keypair is valid by encrypting then decrypting a random message
    return RETURN_SUCCES;
}

int generate_private_exponent(struct RSA_KEYPAIR *kp_struct) {
    //Compute the inverse of e modular phi in order to obtain the private exponent d
    return RETURN_SUCCES;
}



int get_primes_factors(struct RSA_KEYPAIR *kp_struct) {
    BIGNUM *tmp_value_T = BN_new();
    BIGNUM *tmp_value_F = BN_new();
    BIGNUM *candidate = BN_new();
    
    //get first prime factor
    generate_random_prime(kp_struct->modulus_size, candidate, kp_struct->public_exponent);
    BN_copy(kp_struct->p_factor, candidate);
    BN_clear(candidate);


    //get second prime factor
    BN_set_word(tmp_value_T, pow(2, kp_struct->modulus_size/2-100));
    while (1) {
        generate_random_prime(kp_struct->modulus_size, candidate, kp_struct->public_exponent);
        BN_sub(tmp_value_F, kp_struct->p_factor, candidate);
        
        if (BN_cmp(tmp_value_F, tmp_value_T) == 1) {    //specific condition that need both primes factors
            BN_copy(kp_struct->q_factor, candidate);
            break;
        } 
        BN_clear(candidate);
    }
    

    //free memory of sensitive data
    BN_free(candidate);
    BN_free(tmp_value_T);
    BN_free(tmp_value_F);

    return RETURN_SUCCES;
}



int rsa_generation(int e, int modulus_size) {
    //main function that call the function that generate the keypair

    if (modulus_size < 2048 || modulus_size > 8192 || modulus_size%2 == 0) {
        printf("[!] Incorrect key size. Available key size are between 2048 and 8192 included\n");
        return RETURN_FAILURE;
    }

    if (e < MIN_E_VALUE || e > MAX_E_VALUE || e%2 == 0) {
        printf ("[!] Incorrect public exponent. e shall be in the range of [2**16, 2**256] and odd\n");
        return RETURN_FAILURE;
    } 

    struct RSA_KEYPAIR *kp_struct = &(struct RSA_KEYPAIR) {};

    //put len of the key in KEYPAIR struct
    kp_struct->modulus_size = modulus_size;

    //put public exponent in the KEYPAIR struct
    BN_set_word(kp_struct->public_exponent, e);


    //generate prime factors p and q
    get_primes_factors(kp_struct);


    //compute phi number as phi(N) = (p-1) * (q-1)


    //compute private exponent
    generate_private_exponent(kp_struct);

    //pass consistency test
    consistency_test(kp_struct);

    return RETURN_SUCCES;
}