#include "rsa.h"


/*
A few details:
- The public exponent is by default set to 65537, you can indicate your at condition to respect the following range: [2**nBits-1, 2**nBits]
- I didn't implement (yet) the file format for the keypair. Mean that you can access access the key only from the struct

Warning: the keypair generated by this program aren't cryptographically secure !
My implementation is and only for a training purpose.
In consequence, do not use those keypairs for real life purpose !
*/


#define MIN_E_VALUE pow(2, 16)
#define MAX_E_VALUE pow(2, 256)


struct RSA_KEYPAIR {
    BIGNUM *public_modulus;         
    BIGNUM *public_exponent;      
    BIGNUM *private_exponent; 
    BIGNUM *p_factor;
    BIGNUM *q_factor;
    BIGNUM *crt_exp_one;     
    BIGNUM *crt_exp_sec;
};

/* ASN.1 type RSAPrivateKey
RSAPrivateKey ::= SEQUENCE {
    modulus         BIGNUM, -- n
    publicExponent  BIGNUM, -- e
    privateExponent BIGNUM, -- d
    prime1          BIGNUM, -- p
    prime2          BIGNUM, -- q
    crt exponent1   BIGNUM, -- d mod (p-1)
    crt exponent2   BIGNUM, -- d mod (q-1)
*/



int consistency_test(struct RSA_KEYPAIR *kp_struct) {
    //This test verify that the generated keypair is valid by encrypting then decrypting a random message
    return RETURN_SUCCES;
}

int generate_private_exponent(struct RSA_KEYPAIR *kp_struct) {
    //Compute the inverse of e modular phi in order to obtain the private exponent d
    return RETURN_SUCCES;
}


int generate_primes_factors(struct RSA_KEYPAIR *kp_struct) {
    //Pickup two random number until they are both primes
    return RETURN_SUCCES;
}


int rsa_generation(int e, int key_size) {
    //main function that call the function that generate the keypair

    if (key_size < 2048 || key_size > 8192) {
        printf("[!] Incorrect key size. Available key size are between 2048 and 8192 included\n");
        return RETURN_FAILURE;
    }

    if (e < MIN_E_VALUE || e > MAX_E_VALUE) {
        printf ("[!] Incorrect public exponent. It shall be in the range of [2**16, 2**256]\n");
        return RETURN_FAILURE;
    } 

    struct RSA_KEYPAIR *kp_struct = &(struct RSA_KEYPAIR) {};
    BN_CTX *tmp_var = BN_CTX_new();

    //init public exponent
    char chaine[100];
    snprintf(chaine, 100, "%d", e);
    BN_hex2bn(&kp_struct->public_exponent, chaine);

    consistency_test(kp_struct);

    return RETURN_SUCCES;
}