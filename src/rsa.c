#include "rsa.h"


/*
A few details:
- The public exponent is by default set to 65537, you can indicate your at condition to respect the following range: [2**nBits-1, 2**nBits]
- I didn't implement (yet) the file format for the keypair. Mean that you can access access the key only from the struct

Warning: the keypair generated by this program aren't cryptographically secure !
My implementation is and only for a training purpose.
In consequence, do not use those keypairs for real life purpose !
*/


#define MIN_E_VALUE pow(2, 16)
#define MAX_E_VALUE pow(2, 256)


struct RSA_KEYPAIR {
    int key_size;
    BIGNUM *public_modulus;         
    BIGNUM *public_exponent;      
    BIGNUM *private_exponent; 
    BIGNUM *p_factor;
    BIGNUM *q_factor;
    BIGNUM *crt_exp_one;     
    BIGNUM *crt_exp_sec;
};

/* ASN.1 type RSAPrivateKey
RSAPrivateKey ::= SEQUENCE {
    modulus_size    Integer, --nBits
    modulus         BIGNUM, -- n
    publicExponent  BIGNUM, -- e
    privateExponent BIGNUM, -- d
    prime1          BIGNUM, -- p
    prime2          BIGNUM, -- q
    crt exponent1   BIGNUM, -- d mod (p-1)
    crt exponent2   BIGNUM, -- d mod (q-1)
*/



int consistency_test(struct RSA_KEYPAIR *kp_struct) {
    //This test verify that the generated keypair is valid by encrypting then decrypting a random message
    return RETURN_SUCCES;
}

int generate_private_exponent(struct RSA_KEYPAIR *kp_struct) {
    //Compute the inverse of e modular phi in order to obtain the private exponent d
    return RETURN_SUCCES;
}


int generate_primes_factors(struct RSA_KEYPAIR *kp_struct) {
    //Pickup two random number until they are both primes
    BIGNUM *candidate;
    bool round = 0;

    while (round == 0) {
        BN_rand(candidate, kp_struct->key_size/2, -1, 0);
        if (!(BN_is_odd(candidate))) 
            BN_add(candidate, candidate, BN_value_one());

        BN_free(candidate);
    }
    return RETURN_SUCCES;
}


int rsa_generation(int e, int key_size) {
    //main function that call the function that generate the keypair

    if (key_size < 2048 || key_size > 8192) {
        printf("[!] Incorrect key size. Available key size are between 2048 and 8192 included\n");
        return RETURN_FAILURE;
    }

    if (e < MIN_E_VALUE || e > MAX_E_VALUE || e%2 == 1) {
        printf ("[!] Incorrect public exponent. e shall be in the range of [2**16, 2**256] and odd\n");
        return RETURN_FAILURE;
    } 

    struct RSA_KEYPAIR *kp_struct = &(struct RSA_KEYPAIR) {};
    BN_CTX *tmp_var = BN_CTX_new();

    //put len of the key in KEYPAIR struct
    kp_struct->key_size = key_size;

    //put public exponent in the KEYPAIR struct
    char chaine[100];
    snprintf(chaine, 100, "%d", e);
    BN_hex2bn(&kp_struct->public_exponent, chaine);


    //generate prime factors p and q
    generate_primes_factors(kp_struct);


    //compute phi number as phi(N) = (p-1) * (q-1)


    //compute private exponent
    generate_private_exponent(kp_struct);

    //pass consistency test
    consistency_test(kp_struct);

    return RETURN_SUCCES;
}